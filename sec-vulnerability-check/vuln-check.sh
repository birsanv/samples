#!/bin/bash

# Vulnerability Scanner Script for cluster-backup-operator
# This script uses govulncheck to scan for Go vulnerabilities
#
# Usage: ./scripts/vuln-check.sh [options]
# Options:
#   -h, --help     Show this help message
#   -m, --module   Run module-only scan (fast, dependencies only)
#   -s, --symbol   Run symbol scan (detailed, checks actual usage)
#   -b, --binary   Scan compiled binary (if available)
#   -v, --verbose  Show verbose output
#   -a, --all      Run all scan types
#   -i, --install  Install/update govulncheck tool

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
GOVULNCHECK_CMD=""
VERBOSE=false
SCAN_MODULE=false
SCAN_SYMBOL=false
SCAN_BINARY=false
INSTALL_TOOL=false
LAST_SCAN_OUTPUT=""

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${PURPLE}=== $1 ===${NC}"
}

# Help function
show_help() {
    cat << EOF
${CYAN}Vulnerability Scanner for cluster-backup-operator${NC}

${YELLOW}USAGE:${NC}
    $0 [OPTIONS]

${YELLOW}OPTIONS:${NC}
    -h, --help      Show this help message
    -m, --module    Run module-only scan (fast, dependencies only)
    -s, --symbol    Run symbol scan (detailed, checks actual usage)
    -b, --binary    Scan compiled binary (requires make build first)
    -v, --verbose   Show verbose output
    -a, --all       Run all scan types (module + symbol + binary if available)
    -i, --install   Install/update govulncheck tool

${YELLOW}EXAMPLES:${NC}
    $0 -m                    # Quick module scan
    $0 -s -v                 # Detailed symbol scan with verbose output
    $0 -a                    # Run all scans
    $0 -i && $0 -a           # Install tool then run all scans

${YELLOW}SCAN TYPES:${NC}
    ${GREEN}Module Scan${NC}  - Fast scan of all dependencies in go.mod
    ${GREEN}Symbol Scan${NC}  - Detailed scan checking if vulnerable code is actually called
    ${GREEN}Binary Scan${NC}  - Scan compiled binary for vulnerabilities

EOF
}

# Check if govulncheck is installed
check_govulncheck() {
    print_status "Checking for govulncheck installation..."
    
    # Check common locations
    local locations=(
        "$(go env GOPATH)/bin/govulncheck"
        "$HOME/go/bin/govulncheck"
        "$(which govulncheck 2>/dev/null || true)"
    )
    
    for location in "${locations[@]}"; do
        if [[ -x "$location" ]]; then
            GOVULNCHECK_CMD="$location"
            print_success "Found govulncheck at: $location"
            return 0
        fi
    done
    
    print_warning "govulncheck not found!"
    return 1
}

# Install govulncheck
install_govulncheck() {
    print_header "Installing govulncheck"
    print_status "Installing latest version of govulncheck..."
    
    if go install golang.org/x/vuln/cmd/govulncheck@latest; then
        print_success "govulncheck installed successfully!"
        check_govulncheck
    else
        print_error "Failed to install govulncheck"
        exit 1
    fi
}

# Get Go version info
show_go_info() {
    print_header "Go Environment Information"
    echo -e "${CYAN}Go Version:${NC} $(go version)"
    echo -e "${CYAN}GOPATH:${NC} $(go env GOPATH)"
    echo -e "${CYAN}GOROOT:${NC} $(go env GOROOT)"
    echo -e "${CYAN}Project Root:${NC} $PROJECT_ROOT"
    echo
}

# Run module scan
run_module_scan() {
    print_header "Module Vulnerability Scan"
    print_status "Scanning dependencies in go.mod for vulnerabilities..."
    
    cd "$PROJECT_ROOT"
    
    local cmd="$GOVULNCHECK_CMD -scan=module"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd"
    echo
    
    # Capture output to analyze
    local scan_output
    local exit_code
    scan_output=$($cmd 2>&1)
    exit_code=$?
    
    # Store globally for recommendations
    LAST_SCAN_OUTPUT="$scan_output"
    
    # Display the full output first
    echo "$scan_output"
    
    # Parse and categorize vulnerabilities
    if [[ $exit_code -eq 0 ]]; then
        print_success "Module scan completed - no vulnerabilities found!"
        return 0
    elif [[ $exit_code -eq 3 ]]; then
        echo
        analyze_vulnerability_sources "$scan_output"
        print_warning "Module scan found vulnerabilities (exit code 3)"
        return 3
    else
        print_error "Module scan failed with exit code $exit_code"
        return $exit_code
    fi
}

# Analyze and categorize vulnerability sources
analyze_vulnerability_sources() {
    local scan_output="$1"
    
    print_header "🔍 CVE Scan Results for cluster-backup-operator"
    
    # Count standard library vulnerabilities
    local stdlib_count=$(echo "$scan_output" | grep -c "Standard library" || echo "0")
    
    # Count module vulnerabilities (count only "Module:" lines)
    local module_count=$(echo "$scan_output" | grep "Module:" | wc -l | tr -d ' ')
    
    # Get total vulnerabilities
    local total_vulns=$(echo "$scan_output" | grep -E "Your code.*affected by [0-9]+ vulnerabilities" | grep -o '[0-9]\+' | head -1)
    total_vulns=${total_vulns:-0}
    
    # Enhanced summary section
    echo
    if [[ $total_vulns -gt 0 ]]; then
        echo -e "${RED}**Found vulnerabilities!** Here's what I discovered:${NC}"
    else
        echo -e "${GREEN}**Great news!** 🎉 No vulnerabilities found!${NC}"
    fi
    echo
    
    echo -e "${CYAN}### 📊 **Vulnerability Summary:**${NC}"
    echo -e "- **Total CVEs Found:** $total_vulns vulnerabilities"
    echo -e "- **Standard Library:** $stdlib_count CVEs (from Go $(go version | cut -d' ' -f3))"
    if [[ $module_count -gt 0 ]]; then
        echo -e "- **Third-party Dependencies:** $module_count CVE$(if [[ $module_count -gt 1 ]]; then echo "s"; fi) ⚠️"
    else
        echo -e "- **Third-party Dependencies:** $module_count CVEs ✅"
    fi
    echo
    
    # Security assessment
    if [[ $total_vulns -eq 0 ]]; then
        echo -e "${GREEN}### 🏆 **Security Assessment: PERFECT**${NC}"
        echo -e "Your project has an excellent security posture!"
    elif [[ $module_count -eq 0 ]]; then
        echo -e "${YELLOW}### 🥈 **Security Assessment: GOOD**${NC}"
        echo -e "All CVEs are from Go standard library only - excellent dependency management!"
    else
        echo -e "${RED}### 🥉 **Security Assessment: NEEDS ATTENTION**${NC}"
        echo -e "Dependencies need security updates."
    fi
    echo
    
    # Detailed CVE breakdown
    if [[ $total_vulns -gt 0 ]]; then
        echo -e "${CYAN}### 📋 **Detailed CVE Breakdown:**${NC}"
        echo
        
        # Standard Library CVEs
        if [[ $stdlib_count -gt 0 ]]; then
            echo -e "${RED}**🔴 Standard Library CVEs ($stdlib_count):**${NC}"
            
            # Extract and display stdlib vulnerabilities with enhanced format
            local stdlib_vulns=$(echo "$scan_output" | awk '
            /^Vulnerability #[0-9]+:/ { 
                vuln_line = $0; vuln_id = $2; 
                getline; desc_line = $0;
                is_stdlib = 0;
                while ((getline > 0) && ($0 != "") && ($0 !~ /^Vulnerability #[0-9]+:/)) {
                    if ($0 ~ /Standard library/) { is_stdlib = 1; }
                    if ($0 ~ /Module:/) { is_stdlib = 0; break; }
                }
                if (is_stdlib) { print vuln_line "|||" desc_line; }
            }')
            
            while IFS='|||' read -r vuln_line desc_line; do
                if [[ -n "$vuln_line" && -n "$desc_line" ]]; then
                    local vuln_id=$(echo "$vuln_line" | sed 's/.*: //')
                    local vuln_desc=$(echo "$desc_line" | sed 's/^[[:space:]]*//')
                    echo -e "- \`$vuln_id\`: $vuln_desc"
                fi
            done <<< "$stdlib_vulns"
            echo
        fi
        
        # Third-party Dependencies CVEs
        if [[ $module_count -gt 0 ]]; then
            echo -e "${YELLOW}**🟡 Third-party Dependencies ($module_count):**${NC}"
            
            # Extract module vulnerabilities with simpler, more robust parsing
            local current_vuln=""
            local current_desc=""
            local current_module=""
            local in_module_section=false
            
            while IFS= read -r line; do
                # Check for vulnerability start
                if [[ "$line" =~ ^Vulnerability\ #[0-9]+:\ (.+) ]]; then
                    current_vuln="${BASH_REMATCH[1]}"
                    in_module_section=false
                    current_module=""
                    # Read description on next line
                    read -r desc_line
                    current_desc="$(echo "$desc_line" | sed 's/^[[:space:]]*//')"
                elif [[ "$line" =~ ^[[:space:]]*Module:\ (.+) ]]; then
                    current_module="${BASH_REMATCH[1]}"
                    in_module_section=true
                elif [[ "$line" =~ ^[[:space:]]*Standard\ library ]]; then
                    in_module_section=false
                elif [[ "$line" =~ ^[[:space:]]*Found\ in:\ (.+) ]] && [[ "$in_module_section" == true ]]; then
                    local found_in="${BASH_REMATCH[1]}"
                    if [[ -n "$current_vuln" && -n "$current_desc" && -n "$current_module" ]]; then
                        echo -e "- \`$current_vuln\`: $current_desc"
                        echo -e "  📦 **Module**: \`$current_module\`"
                        echo -e "  📍 **Found in**: \`$found_in\`"
                        echo
                    fi
                fi
            done <<< "$scan_output"
        fi
        
        # Recommended fixes section
        echo -e "${CYAN}### 🚀 **Recommended Fixes:**${NC}"
        echo
        
        if [[ $stdlib_count -gt 0 ]]; then
            echo -e "${YELLOW}1. **Update Go version:**${NC}"
            echo '```bash'
            echo "go install golang.org/dl/go1.23.11@latest"
            echo "go1.23.11 download"
            echo "go mod edit -go=1.23.11"
            echo "go mod tidy"
            echo '```'
            echo
        fi
        
        if [[ $module_count -gt 0 ]]; then
            echo -e "${YELLOW}2. **Update vulnerable dependencies:**${NC}"
            echo '```bash'
            # Extract vulnerable modules for update commands
            local vulnerable_modules=$(echo "$scan_output" | grep -A1 "Module:" | grep "Found in:" | sed 's/.*Found in: //' | sort -u)
            while IFS= read -r module; do
                if [[ -n "$module" ]]; then
                    # Extract package name and suggest update
                    local pkg_name=$(echo "$module" | cut -d'@' -f1)
                    echo "go get -u $pkg_name@latest"
                fi
            done <<< "$vulnerable_modules"
            echo '```'
            echo
        fi
    fi
} # Show recommendations
show_recommendations() {
    print_header "Security Recommendations"
    
    # Check if there were any vulnerabilities in the latest scan output
    local has_stdlib_vulns=false
    local has_dep_vulns=false
    
    # This is a simplified check - in practice, the analysis function sets these
    if [[ -n "$LAST_SCAN_OUTPUT" ]]; then
        if echo "$LAST_SCAN_OUTPUT" | grep -q "Standard library"; then
            has_stdlib_vulns=true
        fi
        if echo "$LAST_SCAN_OUTPUT" | grep -E "Module:.*Found in:" | grep -v "stdlib@" >/dev/null 2>&1; then
            has_dep_vulns=true
        fi
    fi
    
    if $has_stdlib_vulns; then
        echo -e "${RED}🔧 Fix Go Standard Library Vulnerabilities:${NC}"
        echo "  1. Update Go to the latest patch version:"
        echo "     ${CYAN}go install golang.org/dl/go1.23.11@latest${NC}"
        echo "     ${CYAN}go1.23.11 download${NC}"
        echo
        echo "  2. Update go.mod requirement:"
        echo "     ${CYAN}go mod edit -go=1.23.11${NC}"
        echo "     ${CYAN}go mod tidy${NC}"
        echo
    fi
    
    if $has_dep_vulns; then
        echo -e "${YELLOW}🔧 Fix Third-party Dependencies:${NC}"
        echo "  1. Update vulnerable dependencies:"
        echo "     ${CYAN}go get -u vulnerable/package@latest${NC}"
        echo "  2. Review and test updates:"
        echo "     ${CYAN}go mod tidy && make test${NC}"
        echo
    fi
    
    if ! $has_stdlib_vulns && ! $has_dep_vulns; then
        echo -e "${GREEN}✅ No vulnerabilities found! Keep up the great work.${NC}"
        echo
    fi
    
    echo -e "${CYAN}🔄 Ongoing Security Practices:${NC}"
    echo "  • Weekly scans: ${CYAN}./scripts/vuln-check.sh -m${NC}"
    echo "  • Pre-release: ${CYAN}./scripts/vuln-check.sh -a -v${NC}"
    echo "  • CI Integration: Add vulnerability checks to GitHub Actions"
    echo
    
    echo -e "${CYAN}📚 Learn More:${NC}"
    echo "  • Go Security: https://go.dev/security/"
    echo "  • Vulnerability DB: https://pkg.go.dev/vuln/"
    echo
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -m|--module)
                SCAN_MODULE=true
                shift
                ;;
            -s|--symbol)
                SCAN_SYMBOL=true
                shift
                ;;
            -b|--binary)
                SCAN_BINARY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -a|--all)
                SCAN_MODULE=true
                SCAN_SYMBOL=true
                SCAN_BINARY=true
                shift
                ;;
            -i|--install)
                INSTALL_TOOL=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # If no scan options specified, default to module scan
    if ! $SCAN_MODULE && ! $SCAN_SYMBOL && ! $SCAN_BINARY; then
        SCAN_MODULE=true
    fi
}

# Main function
main() {
    parse_args "$@"
    
    echo -e "${PURPLE}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                  Vulnerability Scanner                       ║"
    echo "║              cluster-backup-operator                         ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    show_go_info
    
    # Install govulncheck if requested
    if $INSTALL_TOOL; then
        install_govulncheck
    fi
    
    # Check if govulncheck is available
    if ! check_govulncheck; then
        print_error "govulncheck is not installed!"
        print_status "Install it with: $0 --install"
        print_status "Or manually: go install golang.org/x/vuln/cmd/govulncheck@latest"
        exit 1
    fi
    
    # Track overall results
    local overall_exit_code=0
    local vulnerabilities_found=false
    
    # Run requested scans
    if $SCAN_MODULE; then
        if ! run_module_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_SYMBOL; then
        if ! run_symbol_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_BINARY; then
        if ! run_binary_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    # Show final results
    print_header "Scan Results Summary"
    if $vulnerabilities_found; then
        print_warning "Vulnerabilities were found!"
        show_recommendations
    else
        print_success "No vulnerabilities found in scanned components!"
    fi
    
    exit $overall_exit_code
}

# Run main function with all arguments
main "$@" 