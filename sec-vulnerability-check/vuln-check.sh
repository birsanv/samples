#!/bin/bash

# Vulnerability Scanner Script for cluster-backup-operator
# This script uses govulncheck to scan for Go vulnerabilities
#
# Usage: ./scripts/vuln-check.sh [options]
# Options:
#   -h, --help     Show this help message
#   -m, --module   Run module-only scan (fast, dependencies only)
#   -s, --symbol   Run symbol scan (detailed, checks actual usage)
#   -b, --binary   Scan compiled binary (if available)
#   -v, --verbose  Show verbose output
#   -a, --all      Run all scan types
#   -i, --install  Install/update govulncheck tool

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
GOVULNCHECK_CMD=""
VERBOSE=false
SCAN_MODULE=false
SCAN_SYMBOL=false
SCAN_BINARY=false
INSTALL_TOOL=false
LAST_SCAN_OUTPUT=""

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Function to parse go.mod file and extract dependency versions
parse_gomod_dependencies() {
    local gomod_file="$PROJECT_ROOT/go.mod"
    declare -A gomod_deps
    
    if [[ ! -f "$gomod_file" ]]; then
        print_warning "go.mod file not found at $gomod_file"
        return 1
    fi
    
    # Extract current Go version
    local go_version=$(grep "^go " "$gomod_file" | awk '{print $2}')
    echo "GO_VERSION=$go_version"
    
    # Extract direct dependencies (not indirect)
    local in_require_block=false
    while IFS= read -r line; do
        # Check for require block start
        if [[ "$line" =~ ^require\ \( ]]; then
            in_require_block=true
            continue
        fi
        
        # Check for require block end
        if [[ "$line" =~ ^\) ]] && [[ "$in_require_block" == true ]]; then
            in_require_block=false
            continue
        fi
        
        # Parse single require line or lines within require block
        if [[ "$line" =~ ^require\  ]] || [[ "$in_require_block" == true ]]; then
            # Remove 'require ' prefix and leading/trailing whitespace
            local dep_line=$(echo "$line" | sed 's/^require //' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            
            # Skip empty lines and comments
            [[ -z "$dep_line" || "$dep_line" =~ ^// ]] && continue
            
            # Extract module and version
            if [[ "$dep_line" =~ ^([^[:space:]]+)[[:space:]]+([^[:space:]]+) ]]; then
                local module="${BASH_REMATCH[1]}"
                local version="${BASH_REMATCH[2]}"
                # Remove // indirect comment if present
                version=$(echo "$version" | sed 's/[[:space:]]*\/\/.*$//')
                echo "DEP:$module=$version"
            fi
        fi
    done < "$gomod_file"
}

# Function to get go.mod info for a vulnerable module
get_gomod_info() {
    local vulnerable_module="$1"
    local gomod_deps_output="$2"
    
    # Extract package name (remove version info)
    local pkg_name=$(echo "$vulnerable_module" | cut -d'@' -f1)
    
    # Get current Go version
    local current_go_version=$(echo "$gomod_deps_output" | grep "^GO_VERSION=" | cut -d'=' -f2)
    
    # Try to find exact match first
    local current_version=$(echo "$gomod_deps_output" | grep "^DEP:$pkg_name=" | cut -d'=' -f2)
    
    # If not found, try to find by prefix (for sub-packages)
    if [[ -z "$current_version" ]]; then
        # Look for parent module
        local parent_module=""
        local best_match=""
        while IFS= read -r dep_line; do
            if [[ "$dep_line" =~ ^DEP:(.+)=(.+)$ ]]; then
                local dep_module="${BASH_REMATCH[1]}"
                local dep_version="${BASH_REMATCH[2]}"
                
                # Check if the vulnerable package starts with this dependency
                if [[ "$pkg_name" == "$dep_module"* ]] && [[ ${#dep_module} -gt ${#best_match} ]]; then
                    best_match="$dep_module"
                    current_version="$dep_version"
                fi
            fi
        done <<< "$gomod_deps_output"
        
        if [[ -n "$best_match" ]]; then
            pkg_name="$best_match"
        fi
    fi
    
    echo "PKG:$pkg_name|VERSION:$current_version|GO:$current_go_version"
}

# Function to fetch vulnerability severity from database URL
fetch_vulnerability_severity() {
    local vuln_url="$1"
    local vuln_id="$2"
    
    # Try to fetch severity from the vulnerability database
    if command -v curl >/dev/null 2>&1; then
        local response=$(curl -s --max-time 3 "$vuln_url" 2>/dev/null || echo "")
        
        # Parse JSON response for severity (the API returns JSON)
        if [[ -n "$response" ]]; then
            # Look for severity field in JSON response
            local severity=$(echo "$response" | grep -o '"severity":"[^"]*"' | cut -d'"' -f4 2>/dev/null || echo "")
            if [[ -n "$severity" ]]; then
                echo "$severity"
                return 0
            fi
            
            # Fallback: look for common severity indicators in HTML/text
            if echo "$response" | grep -iq "critical"; then
                echo "CRITICAL"
                return 0
            elif echo "$response" | grep -iq "high"; then
                echo "HIGH"
                return 0
            elif echo "$response" | grep -iq "medium"; then
                echo "MEDIUM"
                return 0
            elif echo "$response" | grep -iq "low"; then
                echo "LOW"
                return 0
            fi
        fi
    fi
    
    # Fallback: try to infer severity from vulnerability ID pattern or description
    case "$vuln_id" in
        *"stack exhaustion"*|*"denial of service"*) echo "MEDIUM" ;;
        *"code execution"*|*"overflow"*) echo "HIGH" ;;
        *"information disclosure"*|*"bypass"*) echo "MEDIUM" ;;
        *) echo "UNKNOWN" ;;
    esac
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${PURPLE}=== $1 ===${NC}"
}

# Help function
show_help() {
    cat << EOF
${CYAN}Vulnerability Scanner for cluster-backup-operator${NC}

${YELLOW}USAGE:${NC}
    $0 [OPTIONS]

${YELLOW}OPTIONS:${NC}
    -h, --help      Show this help message
    -m, --module    Run module-only scan (fast, dependencies only)
    -s, --symbol    Run symbol scan (detailed, checks actual usage)
    -b, --binary    Scan compiled binary (requires make build first)
    -v, --verbose   Show verbose output
    -a, --all       Run all scan types (module + symbol + binary if available)
    -i, --install   Install/update govulncheck tool

${YELLOW}EXAMPLES:${NC}
    $0 -m                    # Quick module scan
    $0 -s -v                 # Detailed symbol scan with verbose output
    $0 -a                    # Run all scans
    $0 -i && $0 -a           # Install tool then run all scans

${YELLOW}SCAN TYPES:${NC}
    ${GREEN}Module Scan${NC}  - Fast scan of all dependencies in go.mod
    ${GREEN}Symbol Scan${NC}  - Detailed scan checking if vulnerable code is actually called
    ${GREEN}Binary Scan${NC}  - Scan compiled binary for vulnerabilities

EOF
}

# Check if govulncheck is installed
check_govulncheck() {
    print_status "Checking for govulncheck installation..."
    
    # Check common locations
    local locations=(
        "$(go env GOPATH)/bin/govulncheck"
        "$HOME/go/bin/govulncheck"
        "$(which govulncheck 2>/dev/null || true)"
    )
    
    for location in "${locations[@]}"; do
        if [[ -x "$location" ]]; then
            GOVULNCHECK_CMD="$location"
            print_success "Found govulncheck at: $location"
            return 0
        fi
    done
    
    print_warning "govulncheck not found!"
    return 1
}

# Install govulncheck
install_govulncheck() {
    print_header "Installing govulncheck"
    print_status "Installing latest version of govulncheck..."
    
    if go install golang.org/x/vuln/cmd/govulncheck@latest; then
        print_success "govulncheck installed successfully!"
        check_govulncheck
    else
        print_error "Failed to install govulncheck"
        exit 1
    fi
}

# Get Go version info
show_go_info() {
    print_header "Go Environment Information"
    echo -e "${CYAN}Go Version:${NC} $(go version)"
    echo -e "${CYAN}GOPATH:${NC} $(go env GOPATH)"
    echo -e "${CYAN}GOROOT:${NC} $(go env GOROOT)"
    echo -e "${CYAN}Project Root:${NC} $PROJECT_ROOT"
    echo
}

# Run module scan
run_module_scan() {
    print_header "Module Vulnerability Scan"
    print_status "Scanning dependencies in go.mod for vulnerabilities..."
    
    cd "$PROJECT_ROOT"
    
    local cmd="$GOVULNCHECK_CMD -scan=module"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd"
    echo
    
    # Capture output to analyze
    local scan_output
    local exit_code
    scan_output=$($cmd 2>&1)
    exit_code=$?
    
    # Store globally for recommendations
    LAST_SCAN_OUTPUT="$scan_output"
    
    # Display the full output only in verbose mode
    if $VERBOSE; then
        echo "$scan_output"
        echo
    fi
    
    # Parse and categorize vulnerabilities
    if [[ $exit_code -eq 0 ]]; then
        print_success "Module scan completed - no vulnerabilities found!"
        return 0
    elif [[ $exit_code -eq 3 ]]; then
        echo
        analyze_vulnerability_sources "$scan_output"
        print_warning "Module scan found vulnerabilities (exit code 3)"
        return 3
    else
        print_error "Module scan failed with exit code $exit_code"
        return $exit_code
    fi
}

# Analyze and categorize vulnerability sources
analyze_vulnerability_sources() {
    local scan_output="$1"
    
    print_header "üîç CVE Scan Results for cluster-backup-operator"
    
    # Parse go.mod dependencies for version information
    local gomod_deps_output=$(parse_gomod_dependencies)
    
    # Count standard library vulnerabilities
    local stdlib_count=$(echo "$scan_output" | grep -c "Standard library" || echo "0")
    
    # Count module vulnerabilities (count only "Module:" lines)
    local module_count=$(echo "$scan_output" | grep "Module:" | wc -l | tr -d ' ')
    
    # Get total vulnerabilities
    local total_vulns=$(echo "$scan_output" | grep -E "Your code.*affected by [0-9]+ vulnerabilities" | grep -o '[0-9]\+' | head -1)
    total_vulns=${total_vulns:-0}
    
    # Enhanced summary section
    echo
    if [[ $total_vulns -gt 0 ]]; then
        echo -e "${RED}**Found vulnerabilities!** ${NC}"
    else
        echo -e "${GREEN}**Great news!** üéâ No vulnerabilities found!${NC}"
    fi
    echo
    
    echo -e "${CYAN}### üìä **Vulnerability Summary:**${NC}"
    echo -e "- **Total CVEs Found:** $total_vulns vulnerabilities"
    echo -e "- **Standard Library:** $stdlib_count CVEs (from Go $(go version | cut -d' ' -f3))"
    if [[ $module_count -gt 0 ]]; then
        echo -e "- **Third-party Dependencies:** $module_count CVE$(if [[ $module_count -gt 1 ]]; then echo "s"; fi) ‚ö†Ô∏è"
    else
        echo -e "- **Third-party Dependencies:** $module_count CVEs ‚úÖ"
    fi
    echo
    
    # Security assessment
    if [[ $total_vulns -eq 0 ]]; then
        echo -e "${GREEN}### üèÜ **Security Assessment: PERFECT**${NC}"
        echo -e "Your project has an excellent security posture!"
    elif [[ $module_count -eq 0 ]]; then
        echo -e "${YELLOW}### ü•à **Security Assessment: GOOD**${NC}"
        echo -e "All CVEs are from Go standard library only - excellent dependency management!"
    else
        echo -e "${RED}### ü•â **Security Assessment: NEEDS ATTENTION**${NC}"
        echo -e "Dependencies need security updates."
    fi
    echo
    
    # Detailed CVE breakdown
    if [[ $total_vulns -gt 0 ]]; then
        echo -e "${CYAN}### üìã **Detailed CVE Breakdown:**${NC}"
        print_status "Fetching severity information from vulnerability database..."
        echo
        
        # Standard Library CVEs
        if [[ $stdlib_count -gt 0 ]]; then
            echo -e "${RED}**üî¥ Standard Library CVEs ($stdlib_count):**${NC}"
            
            # Function to output standard library vulnerability information
            output_stdlib_vulnerability() {
                # Fetch severity information
                local severity="UNKNOWN"
                if [[ -n "$current_url" ]]; then
                    severity=$(fetch_vulnerability_severity "$current_url" "$current_desc")
                fi
                
                # Create severity badge
                local severity_badge=""
                case "$severity" in
                    "HIGH") severity_badge="${RED}üî¥ HIGH${NC}" ;;
                    "MEDIUM") severity_badge="${YELLOW}üü° MEDIUM${NC}" ;;
                    "LOW") severity_badge="${GREEN}üü¢ LOW${NC}" ;;
                    "CRITICAL") severity_badge="${RED}üíÄ CRITICAL${NC}" ;;
                    *) severity_badge="${CYAN}‚ùì ${severity}${NC}" ;;
                esac
                
                echo -e "- \`$current_vuln\` [$severity_badge]: $current_desc"
                if [[ -n "$current_fixed_in" ]]; then
                    echo -e "  üîß **Fixed in**: \`$current_fixed_in\`"
                fi
                echo
            }
            
            # Extract stdlib vulnerabilities with severity information
            local current_vuln=""
            local current_desc=""
            local current_url=""
            local current_fixed_in=""
            local in_stdlib_section=false
            
            while IFS= read -r line; do
                # Check for vulnerability start
                if [[ "$line" =~ ^Vulnerability\ #[0-9]+:\ (.+) ]]; then
                    # Output previous vulnerability if we have stdlib info
                    if [[ -n "$current_vuln" && -n "$current_desc" && "$in_stdlib_section" == true ]]; then
                        output_stdlib_vulnerability
                    fi
                    
                    current_vuln="${BASH_REMATCH[1]}"
                    in_stdlib_section=false
                    current_url=""
                    current_fixed_in=""
                    # Read description on next line
                    read -r desc_line
                    current_desc="$(echo "$desc_line" | sed 's/^[[:space:]]*//')"
                elif [[ "$line" =~ ^[[:space:]]*More\ info:\ (.+) ]]; then
                    current_url="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*Standard\ library ]]; then
                    in_stdlib_section=true
                elif [[ "$line" =~ ^[[:space:]]*Fixed\ in:\ (.+) ]] && [[ "$in_stdlib_section" == true ]]; then
                    current_fixed_in="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*Module: ]]; then
                    in_stdlib_section=false
                elif [[ "$line" =~ ^[[:space:]]*Found\ in: ]] && [[ "$in_stdlib_section" == true ]]; then
                    # Don't output here, wait until we collect all info
                    continue
                fi
            done <<< "$scan_output"
            
            # Output the last vulnerability if we have stdlib info
            if [[ -n "$current_vuln" && -n "$current_desc" && "$in_stdlib_section" == true ]]; then
                output_stdlib_vulnerability
            fi
            echo
        fi
        
        # Third-party Dependencies CVEs
        if [[ $module_count -gt 0 ]]; then
            echo -e "${YELLOW}**üü° Third-party Dependencies ($module_count):**${NC}"
            
            # Function to output module vulnerability information
            output_module_vulnerability() {
                # Fetch severity information
                local severity="UNKNOWN"
                if [[ -n "$current_url" ]]; then
                    severity=$(fetch_vulnerability_severity "$current_url" "$current_desc")
                fi
                
                # Create severity badge
                local severity_badge=""
                case "$severity" in
                    "HIGH") severity_badge="${RED}üî¥ HIGH${NC}" ;;
                    "MEDIUM") severity_badge="${YELLOW}üü° MEDIUM${NC}" ;;
                    "LOW") severity_badge="${GREEN}üü¢ LOW${NC}" ;;
                    "CRITICAL") severity_badge="${RED}üíÄ CRITICAL${NC}" ;;
                    *) severity_badge="${CYAN}‚ùì ${severity}${NC}" ;;
                esac
                
                # Get go.mod information for this vulnerable module
                local gomod_info=$(get_gomod_info "$found_in" "$gomod_deps_output")
                local gomod_pkg=$(echo "$gomod_info" | cut -d'|' -f1 | cut -d':' -f2)
                local gomod_version=$(echo "$gomod_info" | cut -d'|' -f2 | cut -d':' -f2)
                
                echo -e "- \`$current_vuln\` [$severity_badge]: $current_desc"
                echo -e "  üì¶ **Module**: \`$current_module\`"
                echo -e "  üìç **Found in**: \`$found_in\`"
                if [[ -n "$current_fixed_in" ]]; then
                    echo -e "  üîß **Fixed in**: \`$current_fixed_in\`"
                fi
                if [[ -n "$gomod_pkg" && -n "$gomod_version" ]]; then
                    echo -e "  üìÑ **go.mod**: \`$gomod_pkg@$gomod_version\` ‚Üí update to \`@latest\`"
                fi
                echo
            }
            
            # Extract module vulnerabilities with severity information
            local current_vuln=""
            local current_desc=""
            local current_module=""
            local current_url=""
            local current_fixed_in=""
            local found_in=""
            local in_module_section=false
            
            while IFS= read -r line; do
                # Check for vulnerability start
                if [[ "$line" =~ ^Vulnerability\ #[0-9]+:\ (.+) ]]; then
                    # Output previous vulnerability if we have module info
                    if [[ -n "$current_vuln" && -n "$current_desc" && -n "$current_module" ]]; then
                        output_module_vulnerability
                    fi
                    
                    current_vuln="${BASH_REMATCH[1]}"
                    in_module_section=false
                    current_module=""
                    current_url=""
                    current_fixed_in=""
                    found_in=""
                    # Read description on next line
                    read -r desc_line
                    current_desc="$(echo "$desc_line" | sed 's/^[[:space:]]*//')"
                elif [[ "$line" =~ ^[[:space:]]*More\ info:\ (.+) ]]; then
                    current_url="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*Module:\ (.+) ]]; then
                    current_module="${BASH_REMATCH[1]}"
                    in_module_section=true
                elif [[ "$line" =~ ^[[:space:]]*Fixed\ in:\ (.+) ]] && [[ "$in_module_section" == true ]]; then
                    current_fixed_in="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*Standard\ library ]]; then
                    in_module_section=false
                elif [[ "$line" =~ ^[[:space:]]*Found\ in:\ (.+) ]] && [[ "$in_module_section" == true ]]; then
                    found_in="${BASH_REMATCH[1]}"
                fi
            done <<< "$scan_output"
            
            # Output the last vulnerability if we have module info
            if [[ -n "$current_vuln" && -n "$current_desc" && -n "$current_module" ]]; then
                output_module_vulnerability
            fi
        fi
        
        # Recommended fixes section
        echo -e "${CYAN}### üöÄ **Recommended Fixes:**${NC}"
        echo
        
        if [[ $stdlib_count -gt 0 ]]; then
            echo -e "${YELLOW}1. **Update Go version:**${NC}"
            echo '```bash'
            echo "go install golang.org/dl/go1.23.11@latest"
            echo "go1.23.11 download"
            echo "go mod edit -go=1.23.11"
            echo "go mod tidy"
            echo '```'
            echo
        fi
        
        if [[ $module_count -gt 0 ]]; then
            echo -e "${YELLOW}2. **Update vulnerable dependencies:**${NC}"
            echo '```bash'
            # Extract vulnerable modules for update commands
            local vulnerable_modules=$(echo "$scan_output" | grep -A1 "Module:" | grep "Found in:" | sed 's/.*Found in: //' | sort -u)
            while IFS= read -r module; do
                if [[ -n "$module" ]]; then
                    # Extract package name and suggest update
                    local pkg_name=$(echo "$module" | cut -d'@' -f1)
                    echo "go get -u $pkg_name@latest"
                fi
            done <<< "$vulnerable_modules"
            echo '```'
            echo
        fi
    fi
}

# Run symbol scan
run_symbol_scan() {
    print_header "Symbol Vulnerability Scan"
    print_status "Scanning for vulnerable symbols in actual code usage..."
    
    cd "$PROJECT_ROOT"
    
    local cmd="$GOVULNCHECK_CMD -scan=symbol"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd ."
    echo
    
    # Capture output to analyze
    local scan_output
    local exit_code
    scan_output=$($cmd . 2>&1)
    exit_code=$?
    
    # Store globally for recommendations
    LAST_SCAN_OUTPUT="$scan_output"
    
    # Display the full output first
    echo "$scan_output"
    
    # Parse and categorize vulnerabilities
    if [[ $exit_code -eq 0 ]]; then
        print_success "Symbol scan completed - no vulnerable symbols found in your code!"
        return 0
    elif [[ $exit_code -eq 3 ]]; then
        echo
        analyze_vulnerability_sources "$scan_output"
        print_warning "Symbol scan found vulnerabilities in code that you actually use (exit code 3)"
        return 3
    else
        print_error "Symbol scan failed with exit code $exit_code"
        return $exit_code
    fi
}

# Run binary scan
run_binary_scan() {
    print_header "Binary Vulnerability Scan"
    print_status "Scanning compiled binary for vulnerabilities..."
    
    cd "$PROJECT_ROOT"
    
    # Look for common binary locations
    local binary_paths=(
        "./manager"
        "./bin/manager"
        "./cluster-backup-operator"
        "./bin/cluster-backup-operator"
    )
    
    local binary_found=""
    for binary_path in "${binary_paths[@]}"; do
        if [[ -f "$binary_path" && -x "$binary_path" ]]; then
            binary_found="$binary_path"
            break
        fi
    done
    
    if [[ -z "$binary_found" ]]; then
        print_warning "No compiled binary found. Attempting to build..."
        
        # Try to build the binary
        if command -v make >/dev/null 2>&1 && [[ -f Makefile ]]; then
            print_status "Building binary using make..."
            if make build 2>/dev/null; then
                # Check again for binary
                for binary_path in "${binary_paths[@]}"; do
                    if [[ -f "$binary_path" && -x "$binary_path" ]]; then
                        binary_found="$binary_path"
                        break
                    fi
                done
            fi
        fi
        
        # Try go build as fallback
        if [[ -z "$binary_found" ]]; then
            print_status "Building binary using go build..."
            if go build -o manager . 2>/dev/null; then
                if [[ -f "./manager" ]]; then
                    binary_found="./manager"
                fi
            fi
        fi
        
        if [[ -z "$binary_found" ]]; then
            print_error "Could not find or build binary for scanning"
            print_status "Try: make build"
            print_status "Or: go build -o manager ."
            return 1
        fi
        
        print_success "Binary built successfully: $binary_found"
    else
        print_success "Found existing binary: $binary_found"
    fi
    
    local cmd="$GOVULNCHECK_CMD -scan=binary"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd $binary_found"
    echo
    
    # Capture output to analyze
    local scan_output
    local exit_code
    scan_output=$($cmd "$binary_found" 2>&1)
    exit_code=$?
    
    # Store globally for recommendations
    LAST_SCAN_OUTPUT="$scan_output"
    
    # Display the full output first
    echo "$scan_output"
    
    # Parse and categorize vulnerabilities
    if [[ $exit_code -eq 0 ]]; then
        print_success "Binary scan completed - no vulnerabilities found in compiled binary!"
        return 0
    elif [[ $exit_code -eq 3 ]]; then
        echo
        analyze_vulnerability_sources "$scan_output"
        print_warning "Binary scan found vulnerabilities in the compiled binary (exit code 3)"
        return 3
    else
        print_error "Binary scan failed with exit code $exit_code"
        return $exit_code
    fi
}

# Show recommendations
show_recommendations() {
    print_header "Security Recommendations"
    
    # Check if there were any vulnerabilities in the latest scan output
    local has_stdlib_vulns=false
    local has_dep_vulns=false
    
    # This is a simplified check - in practice, the analysis function sets these
    if [[ -n "$LAST_SCAN_OUTPUT" ]]; then
        if echo "$LAST_SCAN_OUTPUT" | grep -q "Standard library"; then
            has_stdlib_vulns=true
        fi
        if echo "$LAST_SCAN_OUTPUT" | grep -E "Module:.*Found in:" | grep -v "stdlib@" >/dev/null 2>&1; then
            has_dep_vulns=true
        fi
    fi
    
    if $has_stdlib_vulns; then
        echo -e "${RED}üîß Fix Go Standard Library Vulnerabilities:${NC}"
        echo "  1. Update Go to the latest patch version:"
        echo "     ${CYAN}go install golang.org/dl/go1.23.11@latest${NC}"
        echo "     ${CYAN}go1.23.11 download${NC}"
        echo
        echo "  2. Update go.mod requirement:"
        echo "     ${CYAN}go mod edit -go=1.23.11${NC}"
        echo "     ${CYAN}go mod tidy${NC}"
        echo
    fi
    
    if $has_dep_vulns; then
        echo -e "${YELLOW}üîß Fix Third-party Dependencies:${NC}"
        echo "  1. Update vulnerable dependencies:"
        echo "     ${CYAN}go get -u vulnerable/package@latest${NC}"
        echo "  2. Review and test updates:"
        echo "     ${CYAN}go mod tidy && make test${NC}"
        echo
    fi
    
    if ! $has_stdlib_vulns && ! $has_dep_vulns; then
        echo -e "${GREEN}‚úÖ No vulnerabilities found! Keep up the great work.${NC}"
        echo
    fi
    
    echo -e "${CYAN}üîÑ Ongoing Security Practices:${NC}"
    echo "  ‚Ä¢ Weekly scans: ${CYAN}./scripts/vuln-check.sh -m${NC}"
    echo "  ‚Ä¢ Pre-release: ${CYAN}./scripts/vuln-check.sh -a -v${NC}"
    echo "  ‚Ä¢ CI Integration: Add vulnerability checks to GitHub Actions"
    echo
    
    echo -e "${CYAN}üìö Learn More:${NC}"
    echo "  ‚Ä¢ Go Security: https://go.dev/security/"
    echo "  ‚Ä¢ Vulnerability DB: https://pkg.go.dev/vuln/"
    echo
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -m|--module)
                SCAN_MODULE=true
                shift
                ;;
            -s|--symbol)
                SCAN_SYMBOL=true
                shift
                ;;
            -b|--binary)
                SCAN_BINARY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -a|--all)
                SCAN_MODULE=true
                SCAN_SYMBOL=true
                SCAN_BINARY=true
                shift
                ;;
            -i|--install)
                INSTALL_TOOL=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # If no scan options specified, default to module scan
    if ! $SCAN_MODULE && ! $SCAN_SYMBOL && ! $SCAN_BINARY; then
        SCAN_MODULE=true
    fi
}

# Main function
main() {
    parse_args "$@"
    
    echo -e "${PURPLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                  Vulnerability Scanner                       ‚ïë"
    echo "‚ïë              cluster-backup-operator                         ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    
    show_go_info
    
    # Install govulncheck if requested
    if $INSTALL_TOOL; then
        install_govulncheck
    fi
    
    # Check if govulncheck is available
    if ! check_govulncheck; then
        print_error "govulncheck is not installed!"
        print_status "Install it with: $0 --install"
        print_status "Or manually: go install golang.org/x/vuln/cmd/govulncheck@latest"
        exit 1
    fi
    
    # Track overall results
    local overall_exit_code=0
    local vulnerabilities_found=false
    
    # Run requested scans
    if $SCAN_MODULE; then
        if ! run_module_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_SYMBOL; then
        if ! run_symbol_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_BINARY; then
        if ! run_binary_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    # Show final results
    print_header "Scan Results Summary"
    if $vulnerabilities_found; then
        print_warning "Vulnerabilities were found!"
        show_recommendations
    else
        print_success "No vulnerabilities found in scanned components!"
    fi
    
    exit $overall_exit_code
}

# Run main function with all arguments
main "$@" 