#!/bin/bash

# Vulnerability Scanner Script for cluster-backup-operator
# This script uses govulncheck to scan for Go vulnerabilities

# Usage: Copy this folder under the component you want to scan
#
# Then run: ./sec-vulnerability-check/vuln-check.sh [options]
# Options:
#   -h, --help     Show this help message
#   -m, --module   Run module-only scan (fast, dependencies only)
#   -s, --symbol   Run symbol scan (detailed, checks actual usage)
#   -b, --binary   Scan compiled binary (if available)
#   -v, --verbose  Show verbose output
#   -a, --all      Run all scan types
#   -i, --install  Install/update govulncheck tool

# Example : ./sec-vulnerability-check/vuln-check.sh -m -v

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
GOVULNCHECK_CMD=""
VERBOSE=false
SCAN_MODULE=false
SCAN_SYMBOL=false
SCAN_BINARY=false
INSTALL_TOOL=false
LAST_SCAN_OUTPUT=""

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${PURPLE}=== $1 ===${NC}"
}

# Help function
show_help() {
    cat << EOF
${CYAN}Vulnerability Scanner for cluster-backup-operator${NC}

${YELLOW}USAGE:${NC}
    $0 [OPTIONS]

${YELLOW}OPTIONS:${NC}
    -h, --help      Show this help message
    -m, --module    Run module-only scan (fast, dependencies only)
    -s, --symbol    Run symbol scan (detailed, checks actual usage)
    -b, --binary    Scan compiled binary (requires make build first)
    -v, --verbose   Show verbose output
    -a, --all       Run all scan types (module + symbol + binary if available)
    -i, --install   Install/update govulncheck tool

${YELLOW}EXAMPLES:${NC}
    $0 -m                    # Quick module scan
    $0 -s -v                 # Detailed symbol scan with verbose output
    $0 -a                    # Run all scans
    $0 -i && $0 -a           # Install tool then run all scans

${YELLOW}SCAN TYPES:${NC}
    ${GREEN}Module Scan${NC}  - Fast scan of all dependencies in go.mod
    ${GREEN}Symbol Scan${NC}  - Detailed scan checking if vulnerable code is actually called
    ${GREEN}Binary Scan${NC}  - Scan compiled binary for vulnerabilities

EOF
}

# Check if govulncheck is installed
check_govulncheck() {
    print_status "Checking for govulncheck installation..."
    
    # Check common locations
    local locations=(
        "$(go env GOPATH)/bin/govulncheck"
        "$HOME/go/bin/govulncheck"
        "$(which govulncheck 2>/dev/null || true)"
    )
    
    for location in "${locations[@]}"; do
        if [[ -x "$location" ]]; then
            GOVULNCHECK_CMD="$location"
            print_success "Found govulncheck at: $location"
            return 0
        fi
    done
    
    print_warning "govulncheck not found!"
    return 1
}

# Install govulncheck
install_govulncheck() {
    print_header "Installing govulncheck"
    print_status "Installing latest version of govulncheck..."
    
    if go install golang.org/x/vuln/cmd/govulncheck@latest; then
        print_success "govulncheck installed successfully!"
        check_govulncheck
    else
        print_error "Failed to install govulncheck"
        exit 1
    fi
}

# Get Go version info
show_go_info() {
    print_header "Go Environment Information"
    echo -e "${CYAN}Go Version:${NC} $(go version)"
    echo -e "${CYAN}GOPATH:${NC} $(go env GOPATH)"
    echo -e "${CYAN}GOROOT:${NC} $(go env GOROOT)"
    echo -e "${CYAN}Project Root:${NC} $PROJECT_ROOT"
    echo
}

# Run module scan
run_module_scan() {
    print_header "Module Vulnerability Scan"
    print_status "Scanning dependencies in go.mod for vulnerabilities..."
    
    cd "$PROJECT_ROOT"
    
    local cmd="$GOVULNCHECK_CMD -scan=module"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd"
    echo
    
    # Capture output to analyze
    local scan_output
    local exit_code
    scan_output=$($cmd 2>&1)
    exit_code=$?
    
    # Store globally for recommendations
    LAST_SCAN_OUTPUT="$scan_output"
    
    # Display the full output first
    echo "$scan_output"
    
    # Parse and categorize vulnerabilities
    if [[ $exit_code -eq 0 ]]; then
        print_success "Module scan completed - no vulnerabilities found!"
        return 0
    elif [[ $exit_code -eq 3 ]]; then
        echo
        analyze_vulnerability_sources "$scan_output"
        print_warning "Module scan found vulnerabilities (exit code 3)"
        return 3
    else
        print_error "Module scan failed with exit code $exit_code"
        return $exit_code
    fi
}

# Analyze and categorize vulnerability sources
analyze_vulnerability_sources() {
    local scan_output="$1"
    
    print_header "Vulnerability Analysis by Source"
    
    # Count standard library vulnerabilities
    local stdlib_count=$(echo "$scan_output" | grep -c "Standard library" || echo "0")
    
    # Count module vulnerabilities
    local module_count=$(echo "$scan_output" | grep -E "Module:|Found in:.*@" | grep -v "stdlib@" | wc -l | tr -d ' ')
    
    # Get total vulnerabilities
    local total_vulns=$(echo "$scan_output" | grep -E "Your code.*affected by [0-9]+ vulnerabilities" | grep -o '[0-9]\+' | head -1)
    total_vulns=${total_vulns:-0}
    
    # Display categorized results
    if [[ $stdlib_count -gt 0 ]]; then
        echo -e "${RED}🔴 Go Standard Library Vulnerabilities: $stdlib_count${NC}"
        echo "   Source: Your Go version (go.mod requirement)"
        echo "   Fix: Update Go to latest patch version"
        echo
    fi
    
    if [[ $module_count -gt 0 ]]; then
        echo -e "${YELLOW}🟡 Third-party Dependencies: $module_count${NC}"
        echo "   Source: External packages in go.mod"
        echo "   Fix: Update specific dependency versions"
        echo
        
        # Show which modules have vulnerabilities
        local vulnerable_modules=$(echo "$scan_output" | grep -A1 "Module:" | grep "Found in:" | sed 's/.*Found in: //' | sort -u)
        if [[ -n "$vulnerable_modules" ]]; then
            echo -e "${CYAN}Vulnerable dependencies:${NC}"
            while IFS= read -r module; do
                [[ -n "$module" ]] && echo "   • $module"
            done <<< "$vulnerable_modules"
            echo
        fi
    else
        echo -e "${GREEN}✅ Third-party Dependencies: 0 vulnerabilities${NC}"
        echo "   All external packages are secure!"
        echo
    fi
    
    # Summary Table
    echo -e "${CYAN}📊 Vulnerability Summary Table:${NC}"
    echo "┌───────────────────────────┬───────┬────────────────┬──────────────┐"
    echo "│ Source                    │ Count │ Status         │ Action       │"
    echo "├───────────────────────────┼───────┼────────────────┼──────────────┤"
    
    # Standard library row
    if [[ $stdlib_count -gt 0 ]]; then
        printf "│ %-25s │ %-5s │ %-14s │ %-12s │\\n" "Go Standard Library" "$stdlib_count" "🔴 NeedsUpdate" "Update Go"
    else
        printf "│ %-25s │ %-5s │ %-14s │ %-12s │\\n" "Go Standard Library" "0" "✅ Secure" "None"
    fi
    
    # Dependencies row
    if [[ $module_count -gt 0 ]]; then
        printf "│ %-25s │ %-5s │ %-14s │ %-12s │\\n" "Third-party Dependencies" "$module_count" "🟡 NeedsUpdate" "go get -u"
    else
        printf "│ %-25s │ %-5s │ %-14s │ %-12s │\\n" "Third-party Dependencies" "0" "✅ Secure" "None"
    fi
    
    echo "├───────────────────────────┼───────┼────────────────┼──────────────┤"
    printf "│ %-25s │ %-5s │ %-14s │ %-12s │\\n" "TOTAL VULNERABILITIES" "$total_vulns" "$(if [[ $total_vulns -eq 0 ]]; then echo "✅ All Clear"; else echo "⚠️ ActionNeeded"; fi)" "See below"
    echo "└───────────────────────────┴───────┴────────────────┴──────────────┘"
    echo
    
    # Security Score
    if [[ $total_vulns -eq 0 ]]; then
        echo -e "${GREEN}🏆 Security Score: EXCELLENT (0 vulnerabilities)${NC}"
    elif [[ $module_count -eq 0 ]]; then
        echo -e "${YELLOW}🥈 Security Score: GOOD (stdlib only - ${stdlib_count} vulnerabilities)${NC}"
        echo -e "${GREEN}🎉 Excellent! All security issues are from Go standard library only.${NC}"
        echo -e "${GREEN}   Your dependency management is very secure!${NC}"
    else
        echo -e "${RED}🥉 Security Score: NEEDS ATTENTION (${total_vulns} total vulnerabilities)${NC}"
        echo -e "${YELLOW}   Dependencies need updates: ${module_count} vulnerabilities${NC}"
    fi
    
    echo
}

# Run symbol scan
run_symbol_scan() {
    print_header "Symbol Vulnerability Scan"
    print_status "Scanning for actively used vulnerable symbols..."
    
    cd "$PROJECT_ROOT"
    
    local cmd="$GOVULNCHECK_CMD ."
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd"
    echo
    
    if $cmd; then
        print_success "Symbol scan completed - no vulnerabilities found!"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 1 ]]; then
            print_error "Symbol scan failed due to internal error (try updating Go version)"
            return 1
        elif [[ $exit_code -eq 2 ]]; then
            print_warning "Symbol scan found vulnerabilities (exit code 2)"
            return 2
        else
            print_error "Symbol scan failed with exit code $exit_code"
            return $exit_code
        fi
    fi
}

# Run binary scan
run_binary_scan() {
    print_header "Binary Vulnerability Scan"
    
    local binary_path="$PROJECT_ROOT/bin/manager"
    
    if [[ ! -f "$binary_path" ]]; then
        print_warning "Binary not found at $binary_path"
        print_status "Building binary first..."
        
        cd "$PROJECT_ROOT"
        if make build; then
            print_success "Binary built successfully"
        else
            print_error "Failed to build binary"
            return 1
        fi
    fi
    
    if [[ ! -f "$binary_path" ]]; then
        print_error "Binary still not found after build attempt"
        return 1
    fi
    
    print_status "Scanning compiled binary for vulnerabilities..."
    
    local cmd="$GOVULNCHECK_CMD -scan=binary $binary_path"
    if $VERBOSE; then
        cmd="$cmd -show=verbose"
    fi
    
    echo -e "${CYAN}Running:${NC} $cmd"
    echo
    
    if $cmd; then
        print_success "Binary scan completed - no vulnerabilities found!"
        return 0
    else
        local exit_code=$?
        if [[ $exit_code -eq 2 ]]; then
            print_warning "Binary scan found vulnerabilities (exit code 2)"
            return 2
        else
            print_error "Binary scan failed with exit code $exit_code"
            return $exit_code
        fi
    fi
}

# Show recommendations
show_recommendations() {
    print_header "Security Recommendations"
    
    # Check if there were any vulnerabilities in the latest scan output
    local has_stdlib_vulns=false
    local has_dep_vulns=false
    
    # This is a simplified check - in practice, the analysis function sets these
    if [[ -n "$LAST_SCAN_OUTPUT" ]]; then
        if echo "$LAST_SCAN_OUTPUT" | grep -q "Standard library"; then
            has_stdlib_vulns=true
        fi
        if echo "$LAST_SCAN_OUTPUT" | grep -E "Module:.*Found in:" | grep -v "stdlib@" >/dev/null 2>&1; then
            has_dep_vulns=true
        fi
    fi
    
    if $has_stdlib_vulns; then
        echo -e "${RED}🔧 Fix Go Standard Library Vulnerabilities:${NC}"
        echo "  1. Update Go to the latest patch version:"
        echo "     ${CYAN}go install golang.org/dl/go1.23.11@latest${NC}"
        echo "     ${CYAN}go1.23.11 download${NC}"
        echo
        echo "  2. Update go.mod requirement:"
        echo "     ${CYAN}go mod edit -go=1.23.11${NC}"
        echo "     ${CYAN}go mod tidy${NC}"
        echo
    fi
    
    if $has_dep_vulns; then
        echo -e "${YELLOW}🔧 Fix Third-party Dependencies:${NC}"
        echo "  1. Update vulnerable dependencies:"
        echo "     ${CYAN}go get -u vulnerable/package@latest${NC}"
        echo "  2. Review and test updates:"
        echo "     ${CYAN}go mod tidy && make test${NC}"
        echo
    fi
    
    if ! $has_stdlib_vulns && ! $has_dep_vulns; then
        echo -e "${GREEN}✅ No vulnerabilities found! Keep up the great work.${NC}"
        echo
    fi
    
    echo -e "${CYAN}🔄 Ongoing Security Practices:${NC}"
    echo "  • Weekly scans: ${CYAN}./scripts/vuln-check.sh -m${NC}"
    echo "  • Pre-release: ${CYAN}./scripts/vuln-check.sh -a -v${NC}"
    echo "  • CI Integration: Add vulnerability checks to GitHub Actions"
    echo
    
    echo -e "${CYAN}📚 Learn More:${NC}"
    echo "  • Go Security: https://go.dev/security/"
    echo "  • Vulnerability DB: https://pkg.go.dev/vuln/"
    echo
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -m|--module)
                SCAN_MODULE=true
                shift
                ;;
            -s|--symbol)
                SCAN_SYMBOL=true
                shift
                ;;
            -b|--binary)
                SCAN_BINARY=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -a|--all)
                SCAN_MODULE=true
                SCAN_SYMBOL=true
                SCAN_BINARY=true
                shift
                ;;
            -i|--install)
                INSTALL_TOOL=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # If no scan options specified, default to module scan
    if ! $SCAN_MODULE && ! $SCAN_SYMBOL && ! $SCAN_BINARY; then
        SCAN_MODULE=true
    fi
}

# Main function
main() {
    parse_args "$@"
    
    echo -e "${PURPLE}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                  Vulnerability Scanner                       ║"
    echo "║              cluster-backup-operator                         ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    show_go_info
    
    # Install govulncheck if requested
    if $INSTALL_TOOL; then
        install_govulncheck
    fi
    
    # Check if govulncheck is available
    if ! check_govulncheck; then
        print_error "govulncheck is not installed!"
        print_status "Install it with: $0 --install"
        print_status "Or manually: go install golang.org/x/vuln/cmd/govulncheck@latest"
        exit 1
    fi
    
    # Track overall results
    local overall_exit_code=0
    local vulnerabilities_found=false
    
    # Run requested scans
    if $SCAN_MODULE; then
        if ! run_module_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_SYMBOL; then
        if ! run_symbol_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    if $SCAN_BINARY; then
        if ! run_binary_scan; then
            vulnerabilities_found=true
            overall_exit_code=1
        fi
        echo
    fi
    
    # Show final results
    print_header "Scan Results Summary"
    if $vulnerabilities_found; then
        print_warning "Vulnerabilities were found!"
        show_recommendations
    else
        print_success "No vulnerabilities found in scanned components!"
    fi
    
    exit $overall_exit_code
}

# Run main function with all arguments
main "$@" 